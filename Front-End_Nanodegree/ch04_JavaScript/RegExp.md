# 정규표현식
정규표현식은 정교한 문자열 매칭 기능을 제공합니다. 이메일 주소, URL, 전화번호처럼 보이는 문자열을 찾으려면 정규표현식에 익숙해져야 합니다. 문자열 매칭 그리고 문자열 교체 작업을 지원합니다.
## 정규식 만들기
```javascript
//간단한 정규식을 만들어봅니다.
const input = "As I was going to Saint Ives";
//단어 going 을 찾을 수 있는 정규식
const re1 = /going/;
//생성자를 사용했지만 위의 /going/ 과 결과는 같습니다.
const re2 = new RegExp('going');
```
일부 특수한 경우를 제외하면 re1 같은 간편한 리터럴 문법을 써야 합니다.
## 정규식 검색
```javascript
//예시: 3 글자 이상 + 대소문자 가리지 않음 + 모두 일치
const re = /\w{3,}/ig;

input.match(re);  //['was', 'going', 'Saint', 'Ives']
input.search(re); //세 글자 이상인 첫 단어의 인덱스 : 5
//정규식 메소드를 사용할 경우
re.exec(input); //처음 일치하는 ['was']
re.exec(input); //exec 는 마지막 위치를 기억합니다. ['going']
re.exec(input); //['Saint']
re.exec(input); //['Ives']
re.exec(input); //null 일치하는 것이 더이상 없습니다.
re.test(input); //true : input 은 세 글자 이상인 단어가 한 개 이상 있습니다.
//변수에 저장하지 않고 써도 괜찮습니다.
input.match(/\w{3,}/ig);
/\w{3,}/ig.test(input);
```
참고로 RegExp.prototype.exec 메소드는 많은 정보를 제공해도 가장 적게 쓰입니다. String.prototype.match, RegExp.prototype.test 를 많이 사용합니다.
## 정규식을 사용한 문자열 교체
```javascript
const input = "As I was going to Saint Ives";
const output = input.replace(/\w{4,}/ig, '****');
console.log(output);  //'As I was **** to **** ****'
```
네 글자 이상인 단어를 ****으로 교체하는 작업을 했습니다.
## 입력 소비
정규식은 단순히 '큰 문자열에서 부분 문자열을 찾는 방법'이라고 생각해선 안됩니다. 보다 나은 개념은 정규식이 *입력 문자열을 소비하는 패턴* 이라고 생각하는 겁니다. 찾아낸 부분 문자열은 그렇게 소비한 결과로 만들어진 부산물입니다.
- 소비 : 정규식은 문자열의 글자들을 탐색할 때 첫 알파벳이 찾으려는 단어의 글자와 일치하지 않는다면 첫 알파벳을 `소비`하고 다음 글자로 넘어갑니다. 이렇게 `소비`하다보면 찾는 단어와 일치하는 알파벳이 나올 것입니다. 일치할 가능성이 있으므로 정규식은 그것을 `소비`하지 않습니다. 이런 식으로 맞는 단어를 찾아낸다면 해당 단어를 `소비`하고 다음 알파벳으로 넘어갑니다.
```
X J A N L I O N A T U R E J X E
```
여기서는 LION 을 찾아내서 소비합니다. 그리고 또한 NATURE 도 찾을 수 있는데 아까 LION 에서 N 을 소비했으므로 단어를 만드는 것은 불가능합니다. 왜냐면 정규식은 이미 소비한 것은 절대 다시 보지 않습니다.(즉 일치하는 것을 찾기 위해 뒤로 되돌아가지 않습니다)
- 정규식이 문자열을 `소비`하는 알고리즘
  1. 문자열 왼쪽에서 오른쪽으로 진행합니다.
  2. 일단 소비한 글자로 다시 돌아오는 일은 없습니다.
  3. 한 번에 한 글자씩 움직이며 일치하는 것이 있는지 확인합니다.
  4. 일치하는 것을 찾으면 해당 글자를 한번에 소비한 후 다음 글자로 진행합니다.(이 경우는 정규식 /g 플래그로 전역 검색할 경우에 해당합니다)
## 대체
문자열에 담은 HTML 페이지에서 외부 자원을 가리키는 <a>, <area>, <link>, <script>, <source>, <meta>를 모두 찾고 싶을 때는 어떻게 할까요. 태그의 대소문자가 통일되지 않을 경우도 있습니다. 이럴 때는 정규식의 `대체`를 사용합니다.
```javascript
const html = 'HTML with <a href="/one">one link</a>, and some javascript' +
  '<script src="stuff.js">';
//이 정규식의 의미는 '텍스트에서 area, a, link, script, source 를 대소문자 가리지 말고 모두 찾으라'입니다.
const matches = html.match(/area|a|link|script|source/ig);
```
여기서 `|`(파이프)는 대체를 뜻하는 메타 문자, `ig`는 대소문자 구별 없이 + 전체를 검색한다는 뜻입니다. g 플래그가 없다면 일치하는 것 중 첫 번째만 반환합니다.
정규식은 왼쪽에서 오른쪽으로 평가하기에 area 를 a 보다 먼저 썼습니다. 이 이유는 LION, NATURE 사례에서 알 수 있습니다. a 를 먼저 쓴다면 검색 시 a 를 소비하면 area 를 소비하는 게 불가능해지기 때문입니다. 그러니 이렇게 겹치는 것이 있을 때는 더 큰 것을 먼저 씁니다. 작은 것을 먼저 쓰면 큰 것을 절대 찾지 못하게 됩니다.
## HTML 찾기
정규식은 HTML 을 분석할 수 없습니다. 분석하려면 각 부분을 구성 요소로 완전히 분해할 수 있어야 하는데, 정규식은 아주 간단한 언어만 분석할 수 있습니다. 물론 정규식으로 복잡한 언어를 분석하기도 하지만, 정규식의 한계를 이해하고 상황에 따라 더 알맞은 방법을 찾아야 합니다.
정규식을
```javascript
const html = '<br> [!CDATA[[<br>]]]';
const matches = html.match(/<br>/ig);
console.log(matches) //['<br>', '<br>']
```
여기서의 진짜 <br>태그는 하나입니다. 나머지는 글자 데이터입니다. 정규식은 `<p> <a>aa</a> </p>`같은 계층적 구조에 매우 취약합니다. 다시 말하자면 정규식은 HTML 처럼 매우 복잡한 것을 검색하기에는 알맞지 않습니다.
## 문자셋
`문자셋`은 글자 하나를 다른 것으로 `대체`하는 방법을 간단히 줄인 것입니다.
```javascript
const beer99 = "99 bottles of beer on the wall " +
  'take 1 down and pass it around -- ' +
  '98 bottles of beer on the wall.';

//문자열 안의 숫자를 모두 찾습니다.
const matches = beer99.match(/0|1|2|3|4|5|6|7|8|9/g); //["9", "9", "1", "9", "8"]
//문자셋으로 간략히 표현합니다. m2 가 더 좋은 방법입니다.
const m1 = beer99.match(/[0123456789]/g);
const m2 = beer99.match(/[0-9]/g);

//글자와 숫자, 기타 구두점을 찾습니다.(사실 공백만 빼고 다 찾습니다)
const match = beer99.match(/[\-0-9a-z.]/ig) //75글자. ['9', '9', 'b', 'o'...]
//원래 문자열에서 공백만 찾습니다.
const match2 = beer99.match(/[^\-0-9a-z.]/);
```
- matches 의 방법은 글자를 찾을 때, 숫자와 글자 모두를 찾을 때 각각 또 다시 만들어야 합니다. 그래서 `문자셋`으로 간편히 표현하는 것입니다.
- match 안의 정규식에서 숫자와 알파벳 순서는 중요치 않습니다.(`/[.a-z0-9\-]/ig`도 가능) 하이픈 `-`은 이스케이프`\`해야합니다. 그러지 않으면 하이픈을 범위 표시 메타문자로 간주합니다.
- match2 안의 정규식은 캐럿`^`을 사용했습니다. 캐럿으로 특정 문자, 또는 범위를 제외합니다.
