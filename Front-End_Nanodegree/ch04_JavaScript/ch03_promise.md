# JavaScript promise (Udacity)
## 프로미스
[구글 개발자 페이지](https://developers.google.com/web/fundamentals/primers/promises)
- 자바스크립트는 단일 스레드로 처리합니다. 하지만 여러 일을 처리해야 할 때 하나씩 처리한다면 속도가 느려지게 됩니다.
  + 콜백 함수나 이벤트를 사용해서 처리할 수 있지만 한계가 있습니다. (이벤트는 동일 객체에 여러 번 발생할 수 있는 작업에 좋습니다.)
- 프로미스 기본 :
  + 한 번만 성공 또는 실패할 수 있습니다. 두 번 성공 또는 실패할 수 없고, 성공을 실패로 또는 실패를 성공으로 바꿀 수도 없습니다.
  + 프로미스가 성공이나 실패한 후에 성공/실패 콜백을 추가하면 이벤트가 일찍 발생한 경우에도 올바른 콜백이 호출됩니다.
  + 비동기적인 성공/실패에 유용하게 사용할 수 있습니다.

### 용어
- 프로미스는 `fulfilled`, `rejected`, `pending`, `settled` 라는 용어가 있습니다.
- `fulfilled` : 프로미스 작업이 성공했을 때 사용됩니다.
- `rejected` : 프로미스 작업이 실패했을 때 사용됩니다.
- `pending` : 프로미스 작업 전이라서 성공, 실패 여부는 아직 모르는 상태입니다.
- `settled` : 프로미스 작업이 성공하거나 실패 둘 중 하나나 나온다는 용어입니다. 프로미스는 오직 한 번만 `settle` 합니다.

### 프로미스 타임라인
- 만약 이벤트 리스너를 이벤트가 실행된 후에 설정하면 아무 일도 생기지 않습니다. 그 이벤트가 다시 실행되지 않는다면 이벤트 리스너도 다시는 호출되지 않습니다.
- 이번에는 프로미스로 프로미스가 성공한 후에 그 성공한 값에 대한 액션을 설정한다면 어떤 일이 생길까요. 그 액션은 실행될 것입니다.
```javascript
new Promise(function (resolve, reject) {
  //프로미스는 오직 한번만 settle 하기에 여기서는 hi 만 실행합니다.
  resolve('hi');
  resolve('bye');
})
```
- 프로미스는 메인 스레드에서 실행됩니다. 그 뜻은 프로미스들은 여전히 잠재적으로 블로킹하고 있다는 것입니다.
  + 그래서 프로미스 생성 후 프로미스가 `settle` 하기까지의 시간은 블로킹되어 있고, 그 사이에 작업을 한다면 오랜 시간이 걸리게 될 것입니다.
  + 따라서 프로미스는 긴 시간이 걸리는 연산에 완벽하게 적합하진 않습니다. 프로미스는 단지 비동기적인 작업이 안정화 될 때 어떤 일이 발생할지를 결정합니다.
- 참고 : 프로미스가 유용한 경우
```javascript
/* ajax 요청을 처리하는 것이므로 프로미스에 적합합니다. */
var data = get('data.json');
data.onload = function () {
  analyze(this.responseText);
};
/* worker 는 다른 스레드에서 실행하고 데이터를 메인스레드에서 post 하는 방식입니다.
이 방식은 확실하게 비동기적이므로 프로미스에 적합합니다. */
var worker = new Worker('worker.js');
worker.postMessage(data);
worker.onmessage = doSomething;
```
