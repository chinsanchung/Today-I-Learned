# 프로그머스- 어서와, 자료구조와 알고리즘

### 6강. 알고리즘의 복잡도

#### 개념

- 알고리즘의 복잡도: 프로그램의 이해도가 아닌, 문제를 푸는데 얼만큼의 자원을 요구하는가를 표현할 때 알고리즘의 복잡도라는 말을 사용합니다.
- 자원
    - 시간 복잡도: 문제(데이터)의 크기와 이를 해결하는 데 걸리는 시간 사이의 관계
    - 공간 복잡도: 문제의 크기와 이를 해결하는 데 필요한 메모리 공간 사이의 관계

#### 시간 복잡도

- 구분
    - 평균 시간 복잡도: 임의의 입력 패턴을 가정했을 때 소요되는 시간의 평균
    - 최악 시간 복잡도: 가장 긴 시간을 소요하게 만드는 입력에 따라 소요되는 시간

#### Big O notation

- 점근 표기법의 하나로, 어떤 함수의 증가 양상을 다른 함수와 비교해서 표현합니다. 알고리즘의 복잡도를 표현할 때 흔히 사용합니다.
- O(log n), O(n), O(n^2), O(2^n) 등으로 표기합니다.
- 입력의 크기가 중요하지, 계수는 그다지 중요하지 않습니다.
- 예시: 입력의 크기가 n 일 경우
    - O(log n): 입력의 크기의 로그에 비례하는 시간이 소요됩니다.
    - O(n): 입력의 크기에 비례하는 시간이 소요됩니다.

#### 복잡도 예시들

##### 선형 시간 알고리즘 O(n)

- 예시: n 개의 무작위로 나열된 수에서 최댓값을 찾기
    - 무작위 나열이기에, 하나하나 끝까지 살펴보기 전까지는 값을 알 수 없습니다.
    - 그래서 Average case `O(n)`, Worst case `O(n)` 인 n 에 비례하는 선형 시간이 걸립니다.

##### 로그 시간 알고리즘 O(log n)

- 예시: n 개의 크기 순으로 정렬된 수에서, 특정 값을 찾기
    - n 이 커질수록 n 보다 log n 이 훨씬 작습니다. 그래서 O(log n) 복잡도로 문제를 풀 수 있다면 효율이 좋은 알고리즘이라 할 수 있습니다.

##### 이차 시간 알고리즘 O(n^2)

- 예시: 삽입 정렬(insertion sort)
    - 처음 주어진 배열이 정렬이 되어있다면, 순서를 바꿀 필요 없이 살펴보기만 하면 됩니다. 즉, Best case 로 `O(n)` 시간이 걸립니다.
    - 만약 역순으로 정렬되어있다면, Worst case `O(n^2)` 시간이 걸립니다.

##### 보다 낮은 복잡도를 가진 정렬 알고리즘

- 예시: 병합 정렬(merge sort) O(n * log n)
    - 정렬할 데이터를 반씩 나누어 각각 정렬합니다. `O(log n)` -> 정렬한 데이터를 두 묶음씩 합칩니다. `O(n)` -> 전체적으로는 `O(n * log n)`만큼 시간이 걸립니다.

### 7강. 연결 리스트(Linked Lists) 01



### 8강. 연결 리스트(Linked Lists) 02

