# REST(Representational State Transfer)
[Understanding And Using REST APIs](https://www.smashingmagazine.com/2018/01/understanding-using-rest-api/)
## 정의
`REST`는 월드 와이드 웹(WWW)같은 분산하이퍼미디어 시스템을 위한 소프트웨어 아키텍처의 한 형태입니다. 로이 필딩의 박사학위 논문에서 소개됐습니다.
`REST` 는 API 의 형태를 결정합니다. 그리고 개발자가 API 를 만들 때 따르는 일련의 규칙입니다. 이 규칙 중 하나는 특정 URL 에 연결할 때 데이터(=리소스)를 가져올 수 있어야 한다는 것입니다.
  - 각 URL 을 `요청`이라 하며 데이트를 다시 전달하면 `응답`이라고 합니다.

## 요청
요청은 엔드포인트, 메소드, 헤더, 데이터 로 구성됩니다.
### 엔드포인트
엔드포인트(=경로) : 요청한 URL 입니다. 요청할 리소스를 결정합니다. URL 은 루트엔드포인트 + 경로로 구성됩니다.
  - 예: `https://www.smashingmagazine.com/tag/javascript/` 에서 루트엔트포인트는 `https://www.smashingmagazine.com/`, 경로는 `/tag/javascript/` 입니다. 어떤 경로를 사용할 수 있는지 알려면 API 설명서를 읽어야합니다.
  - API 설명서 : 예를 들어 특정 유저의 레퍼지토리를 보는 방법은 이렇게 적혀 있을 것입니다. `/users/:username/repos` 여기서 ':' 은 변수입니다. 이것을 실제 값으로 대체해야합니다.
엔드포인트의 마지막 부분은 쿼리 매개변수입니다. 기술적으로 쿼리 매개변수는 REST 아키텍처의 일부는 아니지만 많은 API 가 그것들을 사용합니다. 쿼리 매개변수는 키-값의 한 쌍으로 요청을 수정할 옵션을 제공합니다. 이것들은 항상 ?로 시작합니다. 각 매개변수의 쌍은 & 으로 구분합니다. `?query1=value1&query2=value2`
- 참고 : REST API 를 통해 데이터를 보내고 요청하는 공통 형식은 JSON 입니다.

### 요청의 메소드
이 메소드들은 서버에 요청을 전달하는 타입입니다. 5가지 타입이 있습니다. `GET`, `POST`, `PUT`, `PATCH`, `DELETE`
이들은 사용자가 작성한 요청에 대한 의미를 제공합니다. 생성(CREATE), 읽기(READ), 업데이트와 삭제(CRUD)의 4가지 작업을 수행하는데 사용됩니다.

1. GET : 이 요청은 서버에서 자원을 가져 오는 데 사용됩니다. `GET`요청을 수행하면 서버는 요청한 데이터를 찾아서 다시 보냅니다. 즉, `GET`요청은 `READ`연산을 수행합니다. 이는 기본적인 요청 방법입니다.
예시: 사용자로부터 레퍼지토리 목록을 가져오려면 GET 요청이 필요합니다.
2. POST : 이 요청은 서버에 새 리소스를 만드는 데 사용됩니다. `POST`요청을 수행하면, 서버는 데이터베이스에 새로운 항목을 생성하고 생성이 성공했는지 여부를 알려줍니다. 즉, `POST`요청은 `CREATE`연산을 수행합니다.
예시: 새로운 저장소를 만드려면 POST 요청이 필요합니다.
3. PUT, PATCH : 이 두 요청은 서버의 리소스를 업데이트하는 데 사용됩니다. `PUT` 또는 `PATCH`요청을 수행하면 서버는 데이터베이스의 항목을 업데이트하고 업데이트가 성공적인지 여부를 알려줍니다. 즉, 'PUT'또는 'PATCH'요청은 'UPDATE'작업을 수행합니다.
4. DELETE : 이 요청은 서버에서 자원을 삭제하는 데 사용됩니다. `DELETE`요청을 수행하면 서버는 데이터베이스의 항목을 삭제하고 삭제가 성공했는지 여부를 알려줍니다. 즉, `DELETE`요청은 `DELETE`연산을 수행합니다.
### 요청의 헤더
헤더는 클라이언트와 서버에 정보를 제공하는 데 사용됩니다. 본문 내용에 대한 인증 및 정보의 제공 등 다양한 목적으로 사용됩니다.
HTTP 헤더는 콜론 ':' 으로 구분된 프로퍼티-값 쌍입니다. 아래 예제는 JSON 콘텐츠를 원한다고 서버에 알려주는 헤더를 나타냅니다.
```
"Content-Type: application/json". Missing the opening ".
```
### 요청의 데이터
데이터(=본문 또는 메시지)에는 서버로 보내려는 정보가 담겨 있습니다. 이 옵션은 `POST`, `PUT`, `PATCH`, `DELETE` 요청에서만 사용됩니다.
서버를 가동하는 방법을 안다면 API 를 만들고 자신의 데이터를 테스트할 수 있습니다. MongoDB, Node 등으로 서버를 만드는 법을 배워보세요.

## 인증
개발자는 권한이 있는 경우에만 작업을 수행할 수 있도록 조치를 취할 수 있습니다. 이렇게 하면 사칭을 방지할 수 있게 됩니다.
`POST`, `PUT`, `PATCH`, `DELETE` 요청은 데이터베이스를 변경하기 때문에 이 요청들을 인증으로 관리합니다. 경우에 따라서 `GET`요청도 인증이 필요합니다.(예:잔액 확인)
웹 상에서는 두 가지 방식으로 자신을 인증합니다. (이름과 비밀번호 / 비밀 토큰)
- 비밀 토큰은 oAuth 를 포함해서 Github, Google, Twitter, Facebook 등의 SNS 에서 자신을 인증합니다.

## HTTP 상태 코드와 에러 메시지
HTTP 상태 코드로 응답 상태를 알아볼 수 있습니다.
1. 200 번대: 요청 성공 `Success`
2. 300 번대: 요청을 완료하기 위해 추가 동작 `Redirection` 이 필요함
3. 400 번대: 클라이언트 에러. 서버는 요청을 이해 못함
4. 500 번대: 서버 에러. 서버는 요청 처리를 실패함

## API 버전
개발자는 수시로 API 를 업데이트합니다. 경우에 따라선 API 가 너무 많이 바뀌어 개발자가 다른 API 버전으로 업그레이드하기로 결정할 때가 있습니다.
두 가지 방법으로 특정 API 버전을 요청할 수 있습니다.
1. 엔드포인트에 직접 작성하기. 트위터는 이 방법을 사용합니다. 아래 예시의 API 버전은 1.1이며 엔드포인트로 확인이 가능합니다.
```
https://api.twitter.com/1.1/account/settings.json
```
2. 요청 헤더에 작성하기. 깃허브는 이 방법을 사용합니다. 만약 CURL 을 사용한다면 Accept 헤더를 사용해서 버전을 알아볼 수 있습니다.
```
curl https://api.github.com -H Accept:application/vnd.github.v3+json
```

[위키피디아](https://ko.wikipedia.org/wiki/REST)
## REST 인터페이스의 원칙 가이드
자원의 식별 : 요청 내에 기술된 개별 자원을 식별할 수 있어야 한다. 웹 기반의 REST 시스템에서의 URI의 사용을 예로 들 수 있다. 자원 그 자체는 클라이언트가 받는 문서와는 개념적으로 분리되어 있다. 예를 들어, 서버는 데이터베이스 내부의 자료를 직접 전송하는 대신, 데이터베이스 레코드를 HTML, XML이나 JSON 등의 형식으로 전송한다.

메시지를 통한 리소스의 조작 : 클라이언트가 어떤 자원을 지칭하는 메시지와 특정 메타데이터만 가지고 있다면 이것으로 서버 상의 해당 자원을 변경·삭제할 수 있는 충분한 정보를 가지고 있는 것이다.

자기서술적 메시지 : 각 메시지는 자신을 어떻게 처리해야 하는지에 대한 충분한 정보를 포함해야 한다. 예를 들어 MIME type과 같은 인터넷 미디어 타입을 전달한다면, 그 메시지에는 어떤 파서를 이용해야 하는지에 대한 정보도 포함해야 한다. 미디어 타입만 가지고도, 클라이언트는 어떻게 그 내용을 처리해야할 지 알 수 있어야 한다. 메시지를 이해하기 위해 그 내용까지 살펴봐야 한다면, 그 메시지는 자기서술적이 아니다. 예를 들어, 단순히 "application/xml"이라는 미디어 타입은, 실제 내용을 다운로드 받지 않으면 그 메시지만 가지고는 무엇을 해야할지에 대해 충분히 알려주지 못한다.

애플리케이션의 상태에 대한 엔진으로서 하이퍼미디어 : 만약에 클라이언트가 관련된 리소스에 접근하기를 원한다면, 리턴되는 지시자에서 구별될 수 있어야 한다. 충분한 콘텍스트 속에서의 URI를 제공해주는 하이퍼텍스트 링크의 예를 들 수 있겠다.

## REST 의 목표
구성 요소 상호작용의 규모 확장성(scalability of component interactions)
인터페이스의 범용성 (Generality of interfaces)
구성 요소의 독립적인 배포(Independent deployment of components)
중간적 구성요소를 이용해 응답 지연 감소, 보안을 강화, 레거시 시스템을 인캡슐레이션 (Intermediary components to reduce latency, enforce security and encapsulate legacy systems)
